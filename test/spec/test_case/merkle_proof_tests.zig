// This file is generated by write_spec_tests.zig.
// Do not commit changes by hand.

const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const active_preset = @import("preset").active_preset;
const spec_test_options = @import("spec_test_options");
const MerkleProof = @import("../runner/merkle_proof.zig");

const allocator = std.testing.allocator;

test "deneb merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.deneb, .single_merkle_proof).execute(allocator, test_dir);
}

test "deneb merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.deneb, .single_merkle_proof).execute(allocator, test_dir);
}

test "deneb merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.deneb, .single_merkle_proof).execute(allocator, test_dir);
}

test "deneb merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.deneb, .single_merkle_proof).execute(allocator, test_dir);
}

test "electra merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.electra, .single_merkle_proof).execute(allocator, test_dir);
}

test "electra merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.electra, .single_merkle_proof).execute(allocator, test_dir);
}

test "electra merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.electra, .single_merkle_proof).execute(allocator, test_dir);
}

test "electra merkle_proof single_merkle_proof BeaconBlockBody blob_kzg_commitment_merkle_proof__random_block_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/merkle_proof/single_merkle_proof/BeaconBlockBody/blob_kzg_commitment_merkle_proof__random_block_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try MerkleProof.TestCase(.electra, .single_merkle_proof).execute(allocator, test_dir);
}

