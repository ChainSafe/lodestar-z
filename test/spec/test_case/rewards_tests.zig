// This file is generated by write_spec_tests.zig.
// Do not commit changes by hand.

const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const active_preset = @import("preset").active_preset;
const spec_test_options = @import("spec_test_options");
const Rewards = @import("../runner/rewards.zig");

const allocator = std.testing.allocator;

test "phase0 rewards basic full_delay_max_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_delay_max_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic one_attestation_one_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/one_attestation_one_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic proposer_not_in_attestations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/proposer_not_in_attestations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_delay_one_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_delay_one_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_half_correct_target_incorrect_head" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_half_correct_target_incorrect_head",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_correct_target_incorrect_head" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_correct_target_incorrect_head",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_half_incorrect_target_correct_head" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_half_incorrect_target_correct_head",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_mixed_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_mixed_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic duplicate_attestations_at_later_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/duplicate_attestations_at_later_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic full_half_incorrect_target_incorrect_head" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/full_half_incorrect_target_incorrect_head",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_half_incorrect_target_correct_head_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_half_incorrect_target_correct_head_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_half_incorrect_target_incorrect_head_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_half_incorrect_target_incorrect_head_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_correct_target_incorrect_head_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_correct_target_incorrect_head_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak one_attestation_one_correct_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/one_attestation_one_correct_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_half_correct_target_incorrect_head_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_half_correct_target_incorrect_head_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.phase0).execute(allocator, test_dir);
}

test "altair rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "altair rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.altair).execute(allocator, test_dir);
}

test "bellatrix rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.bellatrix).execute(allocator, test_dir);
}

test "capella rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "capella rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.capella).execute(allocator, test_dir);
}

test "deneb rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "deneb rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.deneb).execute(allocator, test_dir);
}

test "electra rewards basic empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic full_all_correct" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/full_all_correct",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic with_slashed_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/with_slashed_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic quarter_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/quarter_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic half_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/half_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic some_very_low_effective_balances_that_did_not_attest" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_did_not_attest",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic all_balances_too_low_for_reward" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/all_balances_too_low_for_reward",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic full_but_partial_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/full_but_partial_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic some_very_low_effective_balances_that_attested" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/some_very_low_effective_balances_that_attested",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic with_not_yet_activated_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/with_not_yet_activated_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards basic with_exited_validators" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/basic/pyspec_tests/with_exited_validators",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak with_exited_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/with_exited_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak full_random_ten_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/full_random_ten_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak with_slashed_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/with_slashed_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak some_very_low_effective_balances_that_did_not_attest_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_did_not_attest_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak empty_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/empty_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak some_very_low_effective_balances_that_attested_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/some_very_low_effective_balances_that_attested_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak with_not_yet_activated_validators_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/with_not_yet_activated_validators_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak full_random_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/full_random_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak full_random_seven_epoch_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/full_random_seven_epoch_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak full_but_partial_participation_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/full_but_partial_participation_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak quarter_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/quarter_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards leak half_full_leak" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/leak/pyspec_tests/half_full_leak",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_low_balances_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_low_balances_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_low_balances_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_low_balances_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_without_leak_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_without_leak_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

test "electra rewards random full_random_without_leak_and_current_exit_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/rewards/random/pyspec_tests/full_random_without_leak_and_current_exit_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Rewards.TestCase(.electra).execute(allocator, test_dir);
}

