// This file is generated by write_spec_tests.zig.
// Do not commit changes by hand.

const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const active_preset = @import("preset").active_preset;
const spec_test_options = @import("spec_test_options");
const Sanity = @import("../runner/sanity.zig");

const allocator = std.testing.allocator;

test "phase0 sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks multiple_attester_slashings_partial_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/multiple_attester_slashings_partial_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_proposal_for_genesis_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_proposal_for_genesis_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_duplicate_attester_slashing_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_duplicate_attester_slashing_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks multiple_attester_slashings_no_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/multiple_attester_slashings_no_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "phase0 sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.phase0).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee_genesis__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks inactivity_scores_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/inactivity_scores_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee_genesis__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks multiple_attester_slashings_partial_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/multiple_attester_slashings_partial_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee_genesis__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks sync_committee_committee__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/sync_committee_committee__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_duplicate_attester_slashing_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_duplicate_attester_slashing_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks inactivity_scores_full_participation_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/inactivity_scores_full_participation_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks multiple_attester_slashings_no_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/multiple_attester_slashings_no_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "altair sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.altair).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee_genesis__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks inactivity_scores_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/inactivity_scores_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks is_execution_enabled_false" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/is_execution_enabled_false",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee_genesis__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks block_transition_randomized_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/block_transition_randomized_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks multiple_attester_slashings_partial_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/multiple_attester_slashings_partial_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee_genesis__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks sync_committee_committee__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/sync_committee_committee__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_duplicate_attester_slashing_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_duplicate_attester_slashing_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks inactivity_scores_full_participation_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/inactivity_scores_full_participation_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_block_transition_no_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_block_transition_no_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks multiple_attester_slashings_no_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/multiple_attester_slashings_no_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "bellatrix sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.bellatrix).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks top_up_and_partial_withdrawable_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/top_up_and_partial_withdrawable_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee_genesis__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_is_execution_enabled_false" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_is_execution_enabled_false",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_two_bls_changes_of_different_addresses_same_validator_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_two_bls_changes_of_different_addresses_same_validator_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks inactivity_scores_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/inactivity_scores_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks withdrawal_success_two_blocks" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/withdrawal_success_two_blocks",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_withdrawal_fail_second_block_payload_isnt_compatible" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_withdrawal_fail_second_block_payload_isnt_compatible",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks activate_and_partial_withdrawal_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee_genesis__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks top_up_to_fully_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/top_up_to_fully_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks block_transition_randomized_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/block_transition_randomized_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks multiple_attester_slashings_partial_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/multiple_attester_slashings_partial_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks full_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/full_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks many_partial_withdrawals_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/many_partial_withdrawals_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee_genesis__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks sync_committee_committee__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/sync_committee_committee__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks exit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/exit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks activate_and_partial_withdrawal_overdeposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_overdeposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks deposit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/deposit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_duplicate_attester_slashing_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_duplicate_attester_slashing_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_duplicate_bls_changes_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_duplicate_bls_changes_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks inactivity_scores_full_participation_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/inactivity_scores_full_participation_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_block_transition_no_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_block_transition_no_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks partial_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/partial_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks multiple_attester_slashings_no_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/multiple_attester_slashings_no_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "capella sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.capella).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks top_up_and_partial_withdrawable_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/top_up_and_partial_withdrawable_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_exceed_max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_exceed_max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee_genesis__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_is_execution_enabled_false" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_is_execution_enabled_false",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_two_bls_changes_of_different_addresses_same_validator_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_two_bls_changes_of_different_addresses_same_validator_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks inactivity_scores_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/inactivity_scores_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks withdrawal_success_two_blocks" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/withdrawal_success_two_blocks",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_withdrawal_fail_second_block_payload_isnt_compatible" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_withdrawal_fail_second_block_payload_isnt_compatible",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks activate_and_partial_withdrawal_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee_genesis__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks top_up_to_fully_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/top_up_to_fully_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks mix_blob_tx_and_non_blob_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/mix_blob_tx_and_non_blob_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks block_transition_randomized_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/block_transition_randomized_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks multiple_attester_slashings_partial_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/multiple_attester_slashings_partial_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks one_blob" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/one_blob",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks full_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/full_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks zero_blob" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/zero_blob",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks many_partial_withdrawals_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/many_partial_withdrawals_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee_genesis__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks sync_committee_committee__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/sync_committee_committee__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks one_blob_two_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/one_blob_two_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_max_blobs_per_block_two_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_max_blobs_per_block_two_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks one_blob_max_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/one_blob_max_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_one_blob_max_plus_one_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_one_blob_max_plus_one_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks exit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/exit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks activate_and_partial_withdrawal_overdeposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_overdeposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks deposit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/deposit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_duplicate_attester_slashing_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_duplicate_attester_slashing_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_duplicate_bls_changes_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_duplicate_bls_changes_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks inactivity_scores_full_participation_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/inactivity_scores_full_participation_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_block_transition_no_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_block_transition_no_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks partial_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/partial_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks multiple_attester_slashings_no_overlap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/multiple_attester_slashings_no_overlap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "deneb sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.deneb).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_incorrect_state_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_incorrect_state_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks eth1_data_votes_no_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/eth1_data_votes_no_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks top_up_and_partial_withdrawable_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/top_up_and_partial_withdrawable_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_exceed_max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_exceed_max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_parent_from_same_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_parent_from_same_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee_genesis__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_is_execution_enabled_false" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_is_execution_enabled_false",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks proposer_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/proposer_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_two_bls_changes_of_different_addresses_same_validator_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_two_bls_changes_of_different_addresses_same_validator_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks inactivity_scores_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/inactivity_scores_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks switch_to_compounding_requests_when_pending_consolidation_queue_is_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/switch_to_compounding_requests_when_pending_consolidation_queue_is_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__start_index_is_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__start_index_is_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks withdrawal_success_two_blocks" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/withdrawal_success_two_blocks",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_withdrawal_fail_second_block_payload_isnt_compatible" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_withdrawal_fail_second_block_payload_isnt_compatible",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__deposit_and_top_up_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__deposit_and_top_up_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks multiple_el_partial_withdrawal_requests_same_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/multiple_el_partial_withdrawal_requests_same_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_epoch_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_epoch_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_incorrect_proposer_index_sig_from_expected_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_expected_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_duplicate_validator_exit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_duplicate_validator_exit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__process_max_eth1_deposits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__process_max_eth1_deposits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__invalid_not_enough_eth1_deposits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__invalid_not_enough_eth1_deposits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks activate_and_partial_withdrawal_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_incorrect_proposer_index_sig_from_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_incorrect_proposer_index_sig_from_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee_genesis__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks withdrawal_requests_when_pending_withdrawal_queue_is_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/withdrawal_requests_when_pending_withdrawal_queue_is_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks multiple_el_partial_withdrawal_requests_different_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/multiple_el_partial_withdrawal_requests_different_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks full_random_operations_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/full_random_operations_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks top_up_to_fully_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/top_up_to_fully_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks switch_to_compounding_requests_when_too_little_consolidation_churn_limit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/switch_to_compounding_requests_when_too_little_consolidation_churn_limit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks multiple_different_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/multiple_different_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks mix_blob_tx_and_non_blob_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/mix_blob_tx_and_non_blob_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks basic_el_withdrawal_request" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/basic_el_withdrawal_request",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks proposer_self_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/proposer_self_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee__empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee__empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks duplicate_attestation_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/duplicate_attestation_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks block_transition_randomized_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/block_transition_randomized_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_duplicate_deposit_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_duplicate_deposit_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_epoch_transition_not_finalizing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_epoch_transition_not_finalizing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks balance_driven_status_transitions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/balance_driven_status_transitions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks full_random_operations_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/full_random_operations_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks slash_and_exit_same_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/slash_and_exit_same_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks one_blob" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/one_blob",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks full_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/full_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks withdrawal_and_consolidation_effective_balance_updates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/withdrawal_and_consolidation_effective_balance_updates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks zero_blob" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/zero_blob",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks basic_btec_and_el_withdrawal_request_in_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/basic_btec_and_el_withdrawal_request_in_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks many_partial_withdrawals_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/many_partial_withdrawals_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks slash_and_exit_diff_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/slash_and_exit_diff_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee_genesis__full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee_genesis__full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks voluntary_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/voluntary_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks skipped_slots" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/skipped_slots",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks sync_committee_committee__half" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/sync_committee_committee__half",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks one_blob_two_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/one_blob_two_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks cl_exit_and_el_withdrawal_request_in_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/cl_exit_and_el_withdrawal_request_in_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_max_blobs_per_block_two_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_max_blobs_per_block_two_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks multiple_different_validator_exits_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/multiple_different_validator_exits_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks withdrawal_and_withdrawal_request_same_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/withdrawal_and_withdrawal_request_same_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks multi_epoch_consolidation_chain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/multi_epoch_consolidation_chain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_duplicate_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_duplicate_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_only_increase_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_only_increase_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks one_blob_max_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/one_blob_max_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks high_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/high_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_one_blob_max_plus_one_txs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_one_blob_max_plus_one_txs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__invalid_eth1_deposits_overlap_in_protocol_deposits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__invalid_eth1_deposits_overlap_in_protocol_deposits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__process_eth1_deposits_up_to_start_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__process_eth1_deposits_up_to_start_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks basic_btec_before_el_withdrawal_request" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/basic_btec_before_el_withdrawal_request",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks exit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/exit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_in_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_in_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks attester_slashing" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/attester_slashing",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_request_max_per_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_request_max_per_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_all_zeroed_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_all_zeroed_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_similar_proposer_slashings_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_similar_proposer_slashings_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks full_random_operations_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/full_random_operations_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks activate_and_partial_withdrawal_overdeposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/activate_and_partial_withdrawal_overdeposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_and_bls_change" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_and_bls_change",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks consolidation_requests_when_pending_consolidation_queue_is_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/consolidation_requests_when_pending_consolidation_queue_is_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__invalid_too_many_eth1_deposits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__invalid_too_many_eth1_deposits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks full_random_operations_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/full_random_operations_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks proposer_after_inactive_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/proposer_after_inactive_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks historical_batch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/historical_batch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_duplicate_bls_changes_same_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_duplicate_bls_changes_same_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_incorrect_block_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_incorrect_block_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__process_eth1_deposits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__process_eth1_deposits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_same_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_same_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks invalid_prev_slot_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/invalid_prev_slot_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_block_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_block_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks inactivity_scores_full_participation_leaking" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/inactivity_scores_full_participation_leaking",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_block_transition_no_tx" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_block_transition_no_tx",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks eth1_data_votes_consensus" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/eth1_data_votes_consensus",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks partial_withdrawal_in_epoch_transition" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/partial_withdrawal_in_epoch_transition",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_request_with_same_pubkey_different_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_request_with_same_pubkey_different_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks withdrawal_and_switch_to_compounding_request_same_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/withdrawal_and_switch_to_compounding_request_same_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks empty_block_transition_large_validator_set" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/empty_block_transition_large_validator_set",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity blocks deposit_transition__deposit_with_same_pubkey_different_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/blocks/pyspec_tests/deposit_transition__deposit_with_same_pubkey_different_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.BlocksTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots slots_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/slots_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots double_empty_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/double_empty_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots multiple_pending_deposits_same_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/multiple_pending_deposits_same_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots over_epoch_boundary" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/over_epoch_boundary",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots multiple_pending_deposits_same_pubkey_above_upward_threshold" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/multiple_pending_deposits_same_pubkey_above_upward_threshold",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots multiple_pending_deposits_same_pubkey_below_upward_threshold" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/multiple_pending_deposits_same_pubkey_below_upward_threshold",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots multiple_pending_deposits_same_pubkey_different_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/multiple_pending_deposits_same_pubkey_different_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots slots_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/slots_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots historical_accumulator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/historical_accumulator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots multiple_pending_deposits_same_pubkey_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/multiple_pending_deposits_same_pubkey_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots pending_consolidation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/pending_consolidation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots pending_deposit_extra_gwei" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/pending_deposit_extra_gwei",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

test "electra sanity slots balance_change_affects_proposer" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/sanity/slots/pyspec_tests/balance_change_affects_proposer",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Sanity.SlotsTestCase(.electra).execute(allocator, test_dir);
}

