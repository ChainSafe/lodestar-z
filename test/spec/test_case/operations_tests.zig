// This file is generated by write_spec_tests.zig.
// Do not commit changes by hand.

const std = @import("std");
const ForkSeq = @import("config").ForkSeq;
const active_preset = @import("preset").active_preset;
const spec_test_options = @import("spec_test_options");
const Operations = @import("../runner/operations.zig");

const allocator = std.testing.allocator;

test "phase0 operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attestation).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .attester_slashing).execute(allocator, test_dir);
}

test "phase0 operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .block_header).execute(allocator, test_dir);
}

test "phase0 operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .deposit).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .proposer_slashing).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "phase0 operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/phase0/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.phase0, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attestation).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .attester_slashing).execute(allocator, test_dir);
}

test "altair operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .block_header).execute(allocator, test_dir);
}

test "altair operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit ineffective_deposit_with_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/ineffective_deposit_with_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations deposit effective_deposit_with_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/deposit/pyspec_tests/effective_deposit_with_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .deposit).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .proposer_slashing).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_all_but_one_participating_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_all_but_one_participating_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_rewards_nonduplicate_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_nonduplicate_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate proposer_in_committee_with_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/proposer_in_committee_with_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_previous_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_previous_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate valid_signature_future_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/valid_signature_future_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate proposer_in_committee_without_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/proposer_in_committee_without_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_infinite_signature_with_single_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_single_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_with_exits_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_with_exits_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_with_nonparticipating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_no_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_no_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_low_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_low_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_only_one_participant_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_only_one_participant_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_high_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_high_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate random_misc_balances_and_half_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/random_misc_balances_and_half_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_bad_domain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_bad_domain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_past_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_past_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_rewards_empty_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_empty_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_extra_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_extra_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_with_nonparticipating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_with_participating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_infinite_signature_with_all_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_all_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_rewards_not_full_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_not_full_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate invalid_signature_missing_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/invalid_signature_missing_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations sync_aggregate sync_committee_with_participating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .sync_aggregate).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "altair operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/altair/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.altair, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attestation).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .attester_slashing).execute(allocator, test_dir);
}

test "bellatrix operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .block_header).execute(allocator, test_dir);
}

test "bellatrix operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit ineffective_deposit_with_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/ineffective_deposit_with_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit effective_deposit_with_genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/effective_deposit_with_genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit ineffective_deposit_with_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/ineffective_deposit_with_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .deposit).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_parent_hash_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_past_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_past_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_pre_randao_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_pre_randao_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_future_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_future_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_everything_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_everything_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload success_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/success_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload randomized_non_validated_execution_fields_first_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_first_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload zero_length_transaction_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/zero_length_transaction_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload success_regular_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/success_regular_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload randomized_non_validated_execution_fields_regular_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_regular_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_execution_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_execution_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_execution_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_execution_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload bad_parent_hash_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/bad_parent_hash_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload success_first_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/success_first_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload non_empty_transactions_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/non_empty_transactions_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload non_empty_transactions_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/non_empty_transactions_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload success_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/success_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_future_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_future_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload non_empty_extra_data_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/non_empty_extra_data_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_prev_randao_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_prev_randao_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_past_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_past_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload zero_length_transaction_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/zero_length_transaction_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload non_empty_extra_data_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/non_empty_extra_data_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations execution_payload invalid_bad_everything_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/execution_payload/pyspec_tests/invalid_bad_everything_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .execution_payload).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .proposer_slashing).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_all_but_one_participating_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_all_but_one_participating_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_rewards_nonduplicate_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_nonduplicate_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate proposer_in_committee_with_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/proposer_in_committee_with_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_previous_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_previous_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate valid_signature_future_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/valid_signature_future_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate proposer_in_committee_without_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/proposer_in_committee_without_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_infinite_signature_with_single_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_single_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_with_exits_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_with_exits_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_with_nonparticipating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_no_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_no_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_low_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_low_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_only_one_participant_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_only_one_participant_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_high_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_high_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate random_misc_balances_and_half_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/random_misc_balances_and_half_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_bad_domain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_bad_domain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_past_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_past_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_rewards_empty_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_empty_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_extra_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_extra_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_with_nonparticipating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_with_participating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_infinite_signature_with_all_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_all_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_rewards_not_full_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_not_full_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate invalid_signature_missing_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/invalid_signature_missing_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations sync_aggregate sync_committee_with_participating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .sync_aggregate).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit voluntary_exit_with_current_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_current_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "bellatrix operations voluntary_exit invalid_voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/bellatrix/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.bellatrix, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attestation).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .attester_slashing).execute(allocator, test_dir);
}

test "capella operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .block_header).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_incorrect_from_bls_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_incorrect_from_bls_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success_in_activation_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success_in_activation_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_bad_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_bad_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change success_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/success_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_already_0x01" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_already_0x01",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_genesis_validators_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_genesis_validators_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations bls_to_execution_change invalid_val_index_out_of_range" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/bls_to_execution_change/pyspec_tests/invalid_val_index_out_of_range",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .bls_to_execution_change).execute(allocator, test_dir);
}

test "capella operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit ineffective_deposit_with_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/ineffective_deposit_with_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit effective_deposit_with_genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/effective_deposit_with_genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit success_top_up_to_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/success_top_up_to_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit ineffective_deposit_with_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/ineffective_deposit_with_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .deposit).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_parent_hash_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_parent_hash_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_past_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_past_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_pre_randao_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_pre_randao_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_future_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_future_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_everything_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_everything_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload success_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/success_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload randomized_non_validated_execution_fields_first_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_first_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload zero_length_transaction_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/zero_length_transaction_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload success_regular_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/success_regular_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload randomized_non_validated_execution_fields_regular_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_regular_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_execution_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_execution_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_execution_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_execution_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload success_first_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/success_first_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload non_empty_transactions_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/non_empty_transactions_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload non_empty_transactions_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/non_empty_transactions_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload success_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/success_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_future_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_future_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload non_empty_extra_data_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/non_empty_extra_data_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_prev_randao_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_prev_randao_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_past_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_past_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload zero_length_transaction_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/zero_length_transaction_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload non_empty_extra_data_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/non_empty_extra_data_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations execution_payload invalid_bad_everything_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/execution_payload/pyspec_tests/invalid_bad_everything_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .execution_payload).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .proposer_slashing).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_all_but_one_participating_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_all_but_one_participating_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_rewards_nonduplicate_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_nonduplicate_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate proposer_in_committee_with_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/proposer_in_committee_with_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_previous_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_previous_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate valid_signature_future_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/valid_signature_future_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate proposer_in_committee_without_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/proposer_in_committee_without_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_infinite_signature_with_single_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_single_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_with_exits_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_with_exits_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_with_nonparticipating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_no_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_no_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_low_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_low_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_only_one_participant_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_only_one_participant_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_high_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_high_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate random_misc_balances_and_half_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/random_misc_balances_and_half_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_bad_domain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_bad_domain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_past_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_past_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_rewards_empty_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_empty_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_extra_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_extra_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_with_nonparticipating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_with_participating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_infinite_signature_with_all_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_all_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_rewards_not_full_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_not_full_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate invalid_signature_missing_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/invalid_signature_missing_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations sync_aggregate sync_committee_with_participating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .sync_aggregate).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit voluntary_exit_with_current_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_current_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations voluntary_exit invalid_voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .voluntary_exit).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_a_lot_fully_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_a_lot_fully_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_two_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_two_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_incorrect_amount_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals all_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/all_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals withdrawable_epoch_but_0_effective_balance_nonzero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_nonzero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals partially_withdrawable_validator_legacy_max_plus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_plus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_excess_balance_but_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_excess_balance_but_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals withdrawable_epoch_but_0_effective_balance_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_one_of_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_full_withdrawals_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_full_withdrawals_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_full_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_full_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawable_exited_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals partially_withdrawable_validator_legacy_max_minus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_minus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_full_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_full_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_mixed_fully_and_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_mixed_fully_and_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_partial_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_partial_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals partially_withdrawable_validator_legacy_exact_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_exact_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals withdrawable_epoch_but_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_incorrect_withdrawal_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_incorrect_withdrawal_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals no_withdrawals_but_some_next_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/no_withdrawals_but_some_next_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_incorrect_address_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_incorrect_address_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_max_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_max_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawable_not_yet_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_not_yet_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawable_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawable_active_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_active_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_all_partially_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_all_partially_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_non_withdrawable_non_empty_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_non_withdrawable_non_empty_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_full_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_full_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_a_lot_partially_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_a_lot_partially_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_one_of_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_max_plus_one_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_max_plus_one_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_zero_expected_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_zero_expected_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_incorrect_address_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_incorrect_address_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_full_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_full_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_one_expected_partial_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_one_expected_partial_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_one_partial_withdrawable_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_partial_withdrawals_5" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_partial_withdrawals_5",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_partial_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_partial_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_one_expected_full_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals success_all_fully_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/success_all_fully_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_partial_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_partial_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals random_partial_withdrawals_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/random_partial_withdrawals_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "capella operations withdrawals invalid_incorrect_amount_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/capella/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.capella, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attestation).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .attester_slashing).execute(allocator, test_dir);
}

test "deneb operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .block_header).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_incorrect_from_bls_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_incorrect_from_bls_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success_in_activation_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success_in_activation_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_bad_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_bad_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change success_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/success_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_already_0x01" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_already_0x01",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_genesis_validators_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_genesis_validators_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations bls_to_execution_change invalid_val_index_out_of_range" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/bls_to_execution_change/pyspec_tests/invalid_val_index_out_of_range",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .bls_to_execution_change).execute(allocator, test_dir);
}

test "deneb operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit ineffective_deposit_with_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/ineffective_deposit_with_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit effective_deposit_with_genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/effective_deposit_with_genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit success_top_up_to_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/success_top_up_to_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit ineffective_deposit_with_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/ineffective_deposit_with_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .deposit).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_parent_hash_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_parent_hash_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_exceed_max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_exceed_max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_past_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_past_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_pre_randao_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_pre_randao_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_transaction_length_1_extra_byte" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_transaction_length_1_extra_byte",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_commitments_order" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_commitments_order",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_transaction_length_empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_transaction_length_empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_future_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_future_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_everything_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_everything_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload success_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/success_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload randomized_non_validated_execution_fields_first_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_first_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_correct_input__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_correct_input__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload zero_length_transaction_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/zero_length_transaction_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload success_regular_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/success_regular_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload randomized_non_validated_execution_fields_regular_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_regular_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_execution_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_execution_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_execution_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_execution_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload no_commitments_for_transactions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/no_commitments_for_transactions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload success_first_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/success_first_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload non_empty_transactions_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/non_empty_transactions_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_transaction_length_32_extra_bytes" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_transaction_length_32_extra_bytes",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload non_empty_transactions_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/non_empty_transactions_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload success_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/success_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_future_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_future_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_commitment" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_commitment",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload zeroed_commitment" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/zeroed_commitment",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload non_empty_extra_data_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/non_empty_extra_data_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload no_transactions_with_commitments" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/no_transactions_with_commitments",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_prev_randao_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_prev_randao_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_past_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_past_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload zero_length_transaction_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/zero_length_transaction_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_transaction_length_1_byte_short" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_transaction_length_1_byte_short",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload non_empty_extra_data_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/non_empty_extra_data_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_block_hash" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_block_hash",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_transaction_no_blobs_but_with_commitments" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_transaction_no_blobs_but_with_commitments",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload incorrect_blob_tx_type" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/incorrect_blob_tx_type",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations execution_payload invalid_bad_everything_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/execution_payload/pyspec_tests/invalid_bad_everything_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .execution_payload).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .proposer_slashing).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_all_but_one_participating_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_all_but_one_participating_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_rewards_nonduplicate_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_nonduplicate_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate proposer_in_committee_with_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/proposer_in_committee_with_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_previous_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_previous_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate valid_signature_future_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/valid_signature_future_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate proposer_in_committee_without_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/proposer_in_committee_without_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_infinite_signature_with_single_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_single_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_with_exits_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_with_exits_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_with_nonparticipating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_no_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_no_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_low_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_low_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_only_one_participant_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_only_one_participant_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_high_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_high_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate random_misc_balances_and_half_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/random_misc_balances_and_half_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_bad_domain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_bad_domain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_past_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_past_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_rewards_empty_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_empty_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_extra_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_extra_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_with_nonparticipating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_with_participating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_infinite_signature_with_all_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_all_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_rewards_not_full_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_not_full_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate invalid_signature_missing_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/invalid_signature_missing_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations sync_aggregate sync_committee_with_participating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .sync_aggregate).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit voluntary_exit_with_previous_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_previous_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .voluntary_exit).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_a_lot_fully_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_a_lot_fully_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_two_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_two_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_incorrect_amount_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals all_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/all_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals withdrawable_epoch_but_0_effective_balance_nonzero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_nonzero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals partially_withdrawable_validator_legacy_max_plus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_plus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_excess_balance_but_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_excess_balance_but_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals withdrawable_epoch_but_0_effective_balance_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_one_of_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_full_withdrawals_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_full_withdrawals_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_full_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_full_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawable_exited_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals partially_withdrawable_validator_legacy_max_minus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_minus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_full_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_full_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_mixed_fully_and_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_mixed_fully_and_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_partial_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_partial_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals partially_withdrawable_validator_legacy_exact_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_exact_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals withdrawable_epoch_but_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_incorrect_withdrawal_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_incorrect_withdrawal_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals no_withdrawals_but_some_next_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/no_withdrawals_but_some_next_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_incorrect_address_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_incorrect_address_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_max_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_max_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawable_not_yet_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_not_yet_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawable_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawable_active_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_active_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_all_partially_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_all_partially_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_non_withdrawable_non_empty_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_non_withdrawable_non_empty_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_full_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_full_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_a_lot_partially_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_a_lot_partially_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_one_of_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_max_plus_one_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_max_plus_one_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_zero_expected_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_zero_expected_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_incorrect_address_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_incorrect_address_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_full_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_full_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_one_expected_partial_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_one_expected_partial_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_one_partial_withdrawable_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_partial_withdrawals_5" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_partial_withdrawals_5",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_partial_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_partial_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_one_expected_full_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals success_all_fully_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/success_all_fully_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_partial_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_partial_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals random_partial_withdrawals_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/random_partial_withdrawals_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "deneb operations withdrawals invalid_incorrect_amount_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/deneb/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.deneb, .withdrawals).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation one_basic_attestation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/one_basic_attestation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_and_target_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_and_target_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_incorrect_head_and_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_incorrect_head_and_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_wrong_index_for_slot_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_nonset_committee_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_nonset_committee_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_empty_participants_zeroes_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_empty_participants_zeroes_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_before_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_before_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_mismatched_target_and_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_mismatched_target_and_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation previous_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/previous_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_wrong_index_for_slot_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_wrong_index_for_slot_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_future_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_future_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation multiple_committees" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/multiple_committees",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_incorrect_head_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_incorrect_head_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation correct_attestation_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/correct_attestation_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_empty_participants_seemingly_valid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_empty_participants_seemingly_valid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation one_committee_with_gap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/one_committee_with_gap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation multi_proposer_index_iterations" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/multi_proposer_index_iterations",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_previous_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_previous_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_too_many_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_too_many_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation correct_attestation_included_at_one_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/correct_attestation_included_at_one_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_nonset_bits_for_one_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_nonset_bits_for_one_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation correct_attestation_included_at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/correct_attestation_included_at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_target_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_target_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_new_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_new_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_correct_attestation_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_correct_attestation_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_and_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_old_source_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_old_source_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation correct_attestation_included_at_min_inclusion_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/correct_attestation_included_at_min_inclusion_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_attestation_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_attestation_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation at_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/at_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_committee_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_committee_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_too_many_committee_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_too_many_committee_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_wrong_index_for_committee_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_wrong_index_for_committee_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_bad_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_bad_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_current_source_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_current_source_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_old_target_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_old_target_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_attestation_data_index_not_zero" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_attestation_data_index_not_zero",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_target_included_at_sqrt_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_target_included_at_sqrt_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation incorrect_head_and_target_included_at_epoch_delay" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/incorrect_head_and_target_included_at_epoch_delay",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_too_few_aggregation_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_too_few_aggregation_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_nonset_multiple_committee_bits" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_nonset_multiple_committee_bits",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_incorrect_target_included_after_max_inclusion_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_incorrect_target_included_after_max_inclusion_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attestation invalid_source_root_is_target_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attestation/pyspec_tests/invalid_source_root_is_target_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attestation).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_all_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_all_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_no_double_or_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_no_double_or_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_unsorted_att_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing basic_surround" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/basic_surround",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing already_exited_recent" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/already_exited_recent",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_bad_replaced_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_bad_replaced_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_same_data" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_same_data",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing misc_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/misc_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_participants_already_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_participants_already_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing proposer_index_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/proposer_index_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_high_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_high_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_unsorted_att_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_unsorted_att_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing low_balances" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/low_balances",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing attestation_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/attestation_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing with_effective_balance_disparity" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/with_effective_balance_disparity",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_bad_extra_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_bad_extra_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_duplicate_index_normal_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_duplicate_index_normal_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_duplicate_index_double_signed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_duplicate_index_double_signed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing already_exited_long_ago" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/already_exited_long_ago",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att1_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att1_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing invalid_att2_empty_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/invalid_att2_empty_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations attester_slashing basic_double" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/attester_slashing/pyspec_tests/basic_double",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .attester_slashing).execute(allocator, test_dir);
}

test "electra operations block_header basic_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/basic_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations block_header invalid_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/invalid_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations block_header invalid_parent_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/invalid_parent_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations block_header invalid_slot_block_header" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/invalid_slot_block_header",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations block_header invalid_multiple_blocks_single_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/invalid_multiple_blocks_single_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations block_header invalid_proposer_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/block_header/pyspec_tests/invalid_proposer_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .block_header).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_incorrect_from_bls_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_incorrect_from_bls_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success_in_activation_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success_in_activation_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_bad_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_bad_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change success_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/success_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_already_0x01" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_already_0x01",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_genesis_validators_root" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_genesis_validators_root",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations bls_to_execution_change invalid_val_index_out_of_range" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/bls_to_execution_change/pyspec_tests/invalid_val_index_out_of_range",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .bls_to_execution_change).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_source_pubkey_is_target_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_source_pubkey_is_target_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_source_with_bls_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_source_with_bls_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_source_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_source_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_no_source_execution_withdrawal_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_no_source_execution_withdrawal_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_source_has_less_than_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_source_has_less_than_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_source_address" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_source_address",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_not_enough_consolidation_churn_available" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_not_enough_consolidation_churn_available",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_target_with_eth1_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_target_with_eth1_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_unknown_source_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_unknown_source_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_exited_source" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_exited_source",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_with_preexisting_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_with_preexisting_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_unknown_target_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_unknown_target_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_exited_target" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_exited_target",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_unknown_source_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_unknown_source_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_not_authorized" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_not_authorized",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request consolidation_balance_larger_than_churn_limit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/consolidation_balance_larger_than_churn_limit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_with_excess_target_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_with_excess_target_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_with_compounding_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_with_compounding_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_exceed_pending_consolidations_limit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_exceed_pending_consolidations_limit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_target_has_less_than_min_activation_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_target_has_less_than_min_activation_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_target_with_bls_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_target_with_bls_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_source_bls_withdrawal_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_source_bls_withdrawal_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_same_source_target" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_same_source_target",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_with_insufficient_preexisting_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_with_insufficient_preexisting_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_exited_source" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_exited_source",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_inactive_source" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_inactive_source",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request consolidation_churn_limit_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/consolidation_churn_limit_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_in_new_consolidation_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_in_new_consolidation_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_with_excess" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_with_excess",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_inactive_source" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_inactive_source",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_inactive_target" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_inactive_target",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request incorrect_source_has_pending_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/incorrect_source_has_pending_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_source_compounding_withdrawal_credential" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_source_compounding_withdrawal_credential",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_switch_to_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_switch_to_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request basic_consolidation_in_current_consolidation_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/basic_consolidation_in_current_consolidation_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request consolidation_balance_through_two_churn_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/consolidation_balance_through_two_churn_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations consolidation_request switch_to_compounding_with_pending_consolidations_at_limit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/consolidation_request/pyspec_tests/switch_to_compounding_with_pending_consolidations_at_limit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .consolidation_request).execute(allocator, test_dir);
}

test "electra operations deposit key_validate_invalid_decompression" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/key_validate_invalid_decompression",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit top_up__less_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/top_up__less_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit new_deposit_non_versioned_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/new_deposit_non_versioned_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit key_validate_invalid_subgroup" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/key_validate_invalid_subgroup",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit ineffective_deposit_with_previous_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/ineffective_deposit_with_previous_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit top_up__zero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/top_up__zero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit incorrect_withdrawal_credentials_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/incorrect_withdrawal_credentials_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit new_deposit_over_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/new_deposit_over_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit invalid_wrong_deposit_for_deposit_count" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/invalid_wrong_deposit_for_deposit_count",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit incorrect_sig_top_up" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/incorrect_sig_top_up",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit top_up__max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/top_up__max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit incorrect_sig_new_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/incorrect_sig_new_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit effective_deposit_with_genesis_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/effective_deposit_with_genesis_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit invalid_bad_merkle_proof" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/invalid_bad_merkle_proof",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit new_deposit_eth1_withdrawal_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/new_deposit_eth1_withdrawal_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit success_top_up_to_withdrawn_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/success_top_up_to_withdrawn_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit new_deposit_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/new_deposit_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit correct_sig_but_forked_state" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/correct_sig_but_forked_state",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit ineffective_deposit_with_bad_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/ineffective_deposit_with_bad_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit ineffective_deposit_with_current_fork_version" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/ineffective_deposit_with_current_fork_version",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit new_deposit_under_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit/pyspec_tests/new_deposit_under_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_greater_than_max_effective_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_greater_than_max_effective_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_set_start_index_only_once" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_set_start_index_only_once",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_top_up_max_effective_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_top_up_max_effective_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_max_effective_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_max_effective_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_set_start_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_set_start_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_top_up_still_less_than_min_activation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_top_up_still_less_than_min_activation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_min_activation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_min_activation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_extra_gwei" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_extra_gwei",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_invalid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_invalid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_top_up_invalid_sig" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_top_up_invalid_sig",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations deposit_request process_deposit_request_top_up_min_activation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/deposit_request/pyspec_tests/process_deposit_request_top_up_min_activation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .deposit_request).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_parent_hash_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_parent_hash_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_parent_hash_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_exceed_max_blobs_per_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_exceed_max_blobs_per_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_past_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_past_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_pre_randao_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_pre_randao_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_transaction_length_1_extra_byte" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_transaction_length_1_extra_byte",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_commitments_order" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_commitments_order",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_transaction_length_empty" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_transaction_length_empty",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_future_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_future_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_everything_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_everything_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload success_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/success_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload randomized_non_validated_execution_fields_first_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_first_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_regular_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_correct_input__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_correct_input__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload zero_length_transaction_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/zero_length_transaction_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload success_regular_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/success_regular_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload randomized_non_validated_execution_fields_regular_payload__execution_valid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/randomized_non_validated_execution_fields_regular_payload__execution_valid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_execution_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_execution_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_execution_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_execution_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload no_commitments_for_transactions" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/no_commitments_for_transactions",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload success_first_payload_with_gap_slot" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/success_first_payload_with_gap_slot",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload non_empty_transactions_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/non_empty_transactions_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_transaction_length_32_extra_bytes" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_transaction_length_32_extra_bytes",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload non_empty_transactions_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/non_empty_transactions_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload success_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/success_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_future_timestamp_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_future_timestamp_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_commitment" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_commitment",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload zeroed_commitment" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/zeroed_commitment",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_randomized_non_validated_execution_fields_first_payload__execution_invalid",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload non_empty_extra_data_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/non_empty_extra_data_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload no_transactions_with_commitments" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/no_transactions_with_commitments",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_prev_randao_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_prev_randao_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_past_timestamp_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_past_timestamp_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload zero_length_transaction_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/zero_length_transaction_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_transaction_length_1_byte_short" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_transaction_length_1_byte_short",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload non_empty_extra_data_regular_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/non_empty_extra_data_regular_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_block_hash" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_block_hash",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_transaction_no_blobs_but_with_commitments" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_transaction_no_blobs_but_with_commitments",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload incorrect_blob_tx_type" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/incorrect_blob_tx_type",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations execution_payload invalid_bad_everything_first_payload" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/execution_payload/pyspec_tests/invalid_bad_everything_first_payload",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .execution_payload).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_slots_of_different_epochs" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_slots_of_different_epochs",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_incorrect_sig_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing block_header_from_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/block_header_from_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_headers_are_same_sigs_are_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_different_proposer_indices" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_different_proposer_indices",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_proposer_is_withdrawn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_withdrawn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_headers_are_same_sigs_are_different" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_headers_are_same_sigs_are_different",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_proposer_is_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing slashed_and_proposer_index_the_same" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/slashed_and_proposer_index_the_same",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_incorrect_sig_1_and_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_incorrect_sig_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_incorrect_sig_1_and_2_swap" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_incorrect_sig_1_and_2_swap",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_proposer_is_not_activated" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_proposer_is_not_activated",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations proposer_slashing invalid_incorrect_proposer_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/proposer_slashing/pyspec_tests/invalid_incorrect_proposer_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .proposer_slashing).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_all_but_one_participating_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_all_but_one_participating_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_rewards_nonduplicate_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_nonduplicate_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate proposer_in_committee_with_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/proposer_in_committee_with_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_previous_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_previous_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate valid_signature_future_committee" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/valid_signature_future_committee",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate proposer_in_committee_without_participation" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/proposer_in_committee_without_participation",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_infinite_signature_with_single_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_single_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_with_exits_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_with_exits_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_with_nonparticipating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_no_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_no_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_low_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_low_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_only_one_participant_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_only_one_participant_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_high_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_high_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate random_misc_balances_and_half_participation_without_duplicates" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/random_misc_balances_and_half_participation_without_duplicates",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_bad_domain" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_bad_domain",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_past_block" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_past_block",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_rewards_empty_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_empty_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_extra_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_extra_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_with_nonparticipating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_with_nonparticipating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_with_participating_withdrawable_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_withdrawable_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_infinite_signature_with_all_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_infinite_signature_with_all_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_rewards_not_full_participants" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_rewards_not_full_participants",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate invalid_signature_missing_participant" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/invalid_signature_missing_participant",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations sync_aggregate sync_committee_with_participating_exited_member" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/sync_aggregate/pyspec_tests/sync_committee_with_participating_exited_member",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .sync_aggregate).execute(allocator, test_dir);
}

test "electra operations voluntary_exit voluntary_exit_with_pending_deposit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_pending_deposit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit min_balance_exits_above_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/min_balance_exits_above_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_exit_in_future" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_exit_in_future",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_genesis_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_previous_fork_version_not_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit success_exit_queue__min_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/success_exit_queue__min_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit success_exit_queue__scaled_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/success_exit_queue__scaled_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit basic" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/basic",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_not_active_long_enough" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active_long_enough",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit voluntary_exit_with_previous_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/voluntary_exit_with_previous_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_voluntary_exit_with_current_fork_version_is_before_fork_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_incorrect_signature" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_incorrect_signature",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_not_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_not_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit min_balance_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/min_balance_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_has_pending_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_has_pending_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit default_exit_epoch_subsequent_exit" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/default_exit_epoch_subsequent_exit",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_incorrect_validator_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_incorrect_validator_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit invalid_validator_already_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/invalid_validator_already_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations voluntary_exit min_balance_exits_up_to_churn" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/voluntary_exit/pyspec_tests/min_balance_exits_up_to_churn",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .voluntary_exit).execute(allocator, test_dir);
}

test "electra operations withdrawal_request no_compounding_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/no_compounding_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request full_exit_request_has_partial_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/full_exit_request_has_partial_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request activation_epoch_less_than_shard_committee_period" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/activation_epoch_less_than_shard_committee_period",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request insufficient_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/insufficient_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request incorrect_withdrawal_credential_prefix" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/incorrect_withdrawal_credential_prefix",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request pending_withdrawals_consume_all_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/pending_withdrawals_consume_all_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request incorrect_source_address" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/incorrect_source_address",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_request_with_pending_withdrawals_and_high_amount" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_request_with_pending_withdrawals_and_high_amount",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_on_exit_initiated_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_on_exit_initiated_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_request_with_high_amount" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_request_with_high_amount",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_withdrawal_request_with_compounding_credentials" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_withdrawal_request_with_compounding_credentials",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_withdrawal_request_with_first_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_withdrawal_request_with_first_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_partial_withdrawal_request_higher_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_partial_withdrawal_request_higher_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request on_withdrawal_request_initiated_exit_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/on_withdrawal_request_initiated_exit_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_activation_epoch_less_than_shard_committee_period" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_activation_epoch_less_than_shard_committee_period",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_partial_withdrawal_request_lower_than_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_partial_withdrawal_request_lower_than_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_request_with_pending_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_request_with_pending_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_withdrawal_request" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_withdrawal_request",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request incorrect_inactive_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/incorrect_inactive_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_incorrect_source_address" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_incorrect_source_address",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_queue_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_queue_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_incorrect_withdrawal_credential_prefix" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_incorrect_withdrawal_credential_prefix",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request unknown_pubkey" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/unknown_pubkey",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request insufficient_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/insufficient_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_withdrawal_request_with_full_partial_withdrawal_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_withdrawal_request_with_full_partial_withdrawal_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_request_with_high_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_request_with_high_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request partial_withdrawal_request_with_low_amount" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/partial_withdrawal_request_with_low_amount",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawal_request basic_partial_withdrawal_request" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawal_request/pyspec_tests/basic_partial_withdrawal_request",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawal_request).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_next_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_next_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_two_partial_withdrawals_same_validator_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_two_partial_withdrawals_same_validator_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_two_expected_partial_withdrawal_and_duplicate_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_a_lot_fully_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_a_lot_fully_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals full_pending_withdrawals_but_first_skipped_low_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/full_pending_withdrawals_but_first_skipped_low_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_no_max_effective_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_no_max_effective_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_with_sweep_different_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_with_sweep_different_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_two_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_two_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_incorrect_amount_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals all_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/all_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals withdrawable_epoch_but_0_effective_balance_nonzero_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_nonzero_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_legacy_max_plus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_plus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_excess_balance_but_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_excess_balance_but_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals withdrawable_epoch_but_0_effective_balance_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_effective_balance_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_one_of_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_full_withdrawals_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_full_withdrawals_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_max_per_slot_full_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_at_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_at_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals full_pending_withdrawals_but_first_skipped_exiting_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/full_pending_withdrawals_but_first_skipped_exiting_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_at_max_mixed_with_sweep_and_fully_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_at_max_mixed_with_sweep_and_fully_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_full_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_full_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_many_incorrectly_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_many_incorrectly_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawable_exited_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_legacy_max_minus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_max_minus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_full_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_full_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_max_minus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_max_minus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_mixed_fully_and_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_mixed_fully_and_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_partial_withdrawals_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_partial_withdrawals_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_with_ineffective_sweep_on_top" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_with_ineffective_sweep_on_top",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_legacy_exact_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_legacy_exact_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_max_per_slot_partial_withdrawals_and_one_less_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals withdrawable_epoch_but_0_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/withdrawable_epoch_but_0_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_incorrect_withdrawal_index" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_incorrect_withdrawal_index",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals no_withdrawals_but_some_next_epoch" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/no_withdrawals_but_some_next_epoch",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_no_max_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_no_max_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_incorrect_address_full" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_incorrect_address_full",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_max_partial_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_max_partial_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals full_pending_withdrawals_but_first_skipped_no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/full_pending_withdrawals_but_first_skipped_no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_min_minus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_min_minus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawable_not_yet_active" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_not_yet_active",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawable_in_exit_queue" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_in_exit_queue",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_two_partial_withdrawals_same_validator_1" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_two_partial_withdrawals_same_validator_1",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_with_effective_sweep_on_top" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_with_effective_sweep_on_top",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawable_active_and_slashed" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_active_and_slashed",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_a_lot_mixed_withdrawable_in_queue_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_max_plus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_max_plus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_low_effective_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_low_effective_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawal" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawal",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_exact_min" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_exact_min",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_all_partially_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_all_partially_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_one_skipped_one_effective" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_one_skipped_one_effective",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_no_excess_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_no_excess_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_non_withdrawable_non_empty_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_non_withdrawable_non_empty_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_0" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_0",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_exact_max" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_exact_max",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_mixed_fully_and_partial_withdrawable_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_mixed_fully_and_partial_withdrawable_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_excess_balance_but_no_max_effective_balance_compounding" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_excess_balance_but_no_max_effective_balance_compounding",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_full_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_full_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_a_lot_partially_withdrawable_too_few_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_a_lot_partially_withdrawable_too_few_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_one_of_many_incorrectly_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_one_of_many_incorrectly_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_mixed_with_sweep_and_fully_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_mixed_with_sweep_and_fully_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_max_plus_one_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_max_plus_one_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_no_excess_balance" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_no_excess_balance",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_zero_expected_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_zero_expected_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_incorrect_address_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_incorrect_address_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_full_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_full_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_exiting_validator" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_exiting_validator",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_one_expected_partial_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_one_expected_partial_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_one_partial_withdrawable_exited" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_one_partial_withdrawable_exited",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_partial_withdrawals_5" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_partial_withdrawals_5",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_partial_withdrawals_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_partial_withdrawals_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals pending_withdrawals_with_ineffective_sweep_on_top_2" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/pending_withdrawals_with_ineffective_sweep_on_top_2",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_one_expected_full_withdrawal_and_none_in_withdrawals" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_one_expected_full_withdrawal_and_none_in_withdrawals",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals success_all_fully_withdrawable" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/success_all_fully_withdrawable",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals partially_withdrawable_validator_compounding_min_plus_one" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/partially_withdrawable_validator_compounding_min_plus_one",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_partial_withdrawals_3" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_partial_withdrawals_3",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals random_partial_withdrawals_4" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/random_partial_withdrawals_4",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

test "electra operations withdrawals invalid_incorrect_amount_partial" {
    const test_dir_name = try std.fs.path.join(allocator, &[_][]const u8{
        spec_test_options.spec_test_out_dir,
        spec_test_options.spec_test_version,
        @tagName(active_preset) ++ "/tests/" ++ @tagName(active_preset) ++ "/electra/operations/withdrawals/pyspec_tests/invalid_incorrect_amount_partial",
    });
    defer allocator.free(test_dir_name);
    const test_dir = std.fs.cwd().openDir(test_dir_name, .{}) catch return error.SkipZigTest;

    try Operations.TestCase(.electra, .withdrawals).execute(allocator, test_dir);
}

